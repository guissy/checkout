// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.27.3
// source: all_in_one.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "payment";

export enum ActionType {
  /** action_type_unspecified - 默认值 */
  action_type_unspecified = "action_type_unspecified",
  /** redirect - 重定向支付 */
  redirect = "redirect",
  /** pin - PIN 支付 */
  pin = "pin",
  /** avs - 地址验证支付 */
  avs = "avs",
  /** sms - 短信验证支付 */
  sms = "sms",
  /** qrcode - 二维码支付 */
  qrcode = "qrcode",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function actionTypeFromJSON(object: any): ActionType {
  switch (object) {
    case 0:
    case "action_type_unspecified":
      return ActionType.action_type_unspecified;
    case 1:
    case "redirect":
      return ActionType.redirect;
    case 2:
    case "pin":
      return ActionType.pin;
    case 3:
    case "avs":
      return ActionType.avs;
    case 4:
    case "sms":
      return ActionType.sms;
    case 5:
    case "qrcode":
      return ActionType.qrcode;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActionType.UNRECOGNIZED;
  }
}

export function actionTypeToJSON(object: ActionType): string {
  switch (object) {
    case ActionType.action_type_unspecified:
      return "action_type_unspecified";
    case ActionType.redirect:
      return "redirect";
    case ActionType.pin:
      return "pin";
    case ActionType.avs:
      return "avs";
    case ActionType.sms:
      return "sms";
    case ActionType.qrcode:
      return "qrcode";
    case ActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function actionTypeToNumber(object: ActionType): number {
  switch (object) {
    case ActionType.action_type_unspecified:
      return 0;
    case ActionType.redirect:
      return 1;
    case ActionType.pin:
      return 2;
    case ActionType.avs:
      return 3;
    case ActionType.sms:
      return 4;
    case ActionType.qrcode:
      return 5;
    case ActionType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** 支付操作类型定义 */
export interface Action {
  /** 支付方法类型 */
  paymentMethodType: string;
  /** 支付页面 URL */
  url: string;
  /** 应用程序跳转链接 */
  applinkUrl?:
    | string
    | undefined;
  /** Scheme URL */
  schemeUrl?:
    | string
    | undefined;
  /** 支付 URL */
  payUrl?:
    | string
    | undefined;
  /** HTTP 方法 */
  method: string;
  /** 支付二维码内容 */
  qrCode: string;
  /** 支付提示信息 */
  message?:
    | string
    | undefined;
  /** 需要填写的支付字段列表 */
  fields: string[];
  /** 支付操作类型 */
  type: ActionType;
}

/** 金额信息 */
export interface Amount {
  /** 货币类型，ISO 4217 三位字母代码 */
  currency: string;
  /** 金额的最小单位值 */
  value: number;
}

/** 订单信息 */
export interface Order {
  /** 付款账户唯一标识 */
  account: string;
  /** 订单金额信息 */
  amount:
    | Amount
    | undefined;
  /** 账户持有人姓名 */
  accountName: string;
  /** 银行名称 */
  bank: string;
  /** 订单过期时间（ISO 8601 格式） */
  expiresAt: string;
  /** 订单备注信息 */
  note: string;
}

/** 客户信息 */
export interface Customer {
  /** 客户唯一 ID */
  id: string;
  /** 客户电话号码，符合 E.164 格式 */
  phone: string;
  /** 客户姓名 */
  name: string;
  /** 客户电子邮件地址 */
  email: string;
  /** 客户创建时间（ISO 8601 格式） */
  createdAt: string;
}

/** API 响应数据 */
export interface AllInOneOutput {
  /** 支付操作相关信息 */
  action?:
    | Action
    | undefined;
  /** 订单金额信息 */
  amount?:
    | Amount
    | undefined;
  /** 订单信息 */
  order?:
    | Order
    | undefined;
  /** 客户信息 */
  customer?:
    | Customer
    | undefined;
  /** 拒绝原因或错误信息 */
  refusalReason: string;
  /** 支付服务提供商的唯一交易参考号 */
  pspReference: string;
  /** 商户的订单参考号 */
  reference?:
    | string
    | undefined;
  /** 交易结果代码 */
  resultCode: string;
}

export interface AllInOneRes {
  data: AllInOneOutput | undefined;
  code: string;
  msg: string;
  serverTime: string;
  success: boolean;
}

function createBaseAction(): Action {
  return {
    paymentMethodType: "",
    url: "",
    applinkUrl: undefined,
    schemeUrl: undefined,
    payUrl: undefined,
    method: "",
    qrCode: "",
    message: undefined,
    fields: [],
    type: ActionType.action_type_unspecified,
  };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentMethodType !== "") {
      writer.uint32(10).string(message.paymentMethodType);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.applinkUrl !== undefined) {
      writer.uint32(26).string(message.applinkUrl);
    }
    if (message.schemeUrl !== undefined) {
      writer.uint32(34).string(message.schemeUrl);
    }
    if (message.payUrl !== undefined) {
      writer.uint32(42).string(message.payUrl);
    }
    if (message.method !== "") {
      writer.uint32(50).string(message.method);
    }
    if (message.qrCode !== "") {
      writer.uint32(58).string(message.qrCode);
    }
    if (message.message !== undefined) {
      writer.uint32(66).string(message.message);
    }
    for (const v of message.fields) {
      writer.uint32(74).string(v!);
    }
    if (message.type !== ActionType.action_type_unspecified) {
      writer.uint32(80).int32(actionTypeToNumber(message.type));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentMethodType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.applinkUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.schemeUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.qrCode = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.fields.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.type = actionTypeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      paymentMethodType: isSet(object.paymentMethodType) ? globalThis.String(object.paymentMethodType) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      applinkUrl: isSet(object.applinkUrl) ? globalThis.String(object.applinkUrl) : undefined,
      schemeUrl: isSet(object.schemeUrl) ? globalThis.String(object.schemeUrl) : undefined,
      payUrl: isSet(object.payUrl) ? globalThis.String(object.payUrl) : undefined,
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      qrCode: isSet(object.qrCode) ? globalThis.String(object.qrCode) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => globalThis.String(e)) : [],
      type: isSet(object.type) ? actionTypeFromJSON(object.type) : ActionType.action_type_unspecified,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.paymentMethodType !== "") {
      obj.paymentMethodType = message.paymentMethodType;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.applinkUrl !== undefined) {
      obj.applinkUrl = message.applinkUrl;
    }
    if (message.schemeUrl !== undefined) {
      obj.schemeUrl = message.schemeUrl;
    }
    if (message.payUrl !== undefined) {
      obj.payUrl = message.payUrl;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.qrCode !== "") {
      obj.qrCode = message.qrCode;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.fields?.length) {
      obj.fields = message.fields;
    }
    if (message.type !== ActionType.action_type_unspecified) {
      obj.type = actionTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action>, I>>(base?: I): Action {
    return Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action>, I>>(object: I): Action {
    const message = createBaseAction();
    message.paymentMethodType = object.paymentMethodType ?? "";
    message.url = object.url ?? "";
    message.applinkUrl = object.applinkUrl ?? undefined;
    message.schemeUrl = object.schemeUrl ?? undefined;
    message.payUrl = object.payUrl ?? undefined;
    message.method = object.method ?? "";
    message.qrCode = object.qrCode ?? "";
    message.message = object.message ?? undefined;
    message.fields = object.fields?.map((e) => e) || [];
    message.type = object.type ?? ActionType.action_type_unspecified;
    return message;
  },
};

function createBaseAmount(): Amount {
  return { currency: "", value: 0 };
}

export const Amount: MessageFns<Amount> = {
  encode(message: Amount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Amount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Amount {
    return {
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Amount): unknown {
    const obj: any = {};
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Amount>, I>>(base?: I): Amount {
    return Amount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Amount>, I>>(object: I): Amount {
    const message = createBaseAmount();
    message.currency = object.currency ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseOrder(): Order {
  return { account: "", amount: undefined, accountName: "", bank: "", expiresAt: "", note: "" };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.amount !== undefined) {
      Amount.encode(message.amount, writer.uint32(18).fork()).join();
    }
    if (message.accountName !== "") {
      writer.uint32(26).string(message.accountName);
    }
    if (message.bank !== "") {
      writer.uint32(34).string(message.bank);
    }
    if (message.expiresAt !== "") {
      writer.uint32(42).string(message.expiresAt);
    }
    if (message.note !== "") {
      writer.uint32(50).string(message.note);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = Amount.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accountName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bank = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expiresAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.note = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      amount: isSet(object.amount) ? Amount.fromJSON(object.amount) : undefined,
      accountName: isSet(object.accountName) ? globalThis.String(object.accountName) : "",
      bank: isSet(object.bank) ? globalThis.String(object.bank) : "",
      expiresAt: isSet(object.expiresAt) ? globalThis.String(object.expiresAt) : "",
      note: isSet(object.note) ? globalThis.String(object.note) : "",
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.amount !== undefined) {
      obj.amount = Amount.toJSON(message.amount);
    }
    if (message.accountName !== "") {
      obj.accountName = message.accountName;
    }
    if (message.bank !== "") {
      obj.bank = message.bank;
    }
    if (message.expiresAt !== "") {
      obj.expiresAt = message.expiresAt;
    }
    if (message.note !== "") {
      obj.note = message.note;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Order>, I>>(base?: I): Order {
    return Order.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Order>, I>>(object: I): Order {
    const message = createBaseOrder();
    message.account = object.account ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Amount.fromPartial(object.amount)
      : undefined;
    message.accountName = object.accountName ?? "";
    message.bank = object.bank ?? "";
    message.expiresAt = object.expiresAt ?? "";
    message.note = object.note ?? "";
    return message;
  },
};

function createBaseCustomer(): Customer {
  return { id: "", phone: "", name: "", email: "", createdAt: "" };
}

export const Customer: MessageFns<Customer> = {
  encode(message: Customer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.phone !== "") {
      writer.uint32(18).string(message.phone);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Customer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Customer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: Customer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Customer>, I>>(base?: I): Customer {
    return Customer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Customer>, I>>(object: I): Customer {
    const message = createBaseCustomer();
    message.id = object.id ?? "";
    message.phone = object.phone ?? "";
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseAllInOneOutput(): AllInOneOutput {
  return {
    action: undefined,
    amount: undefined,
    order: undefined,
    customer: undefined,
    refusalReason: "",
    pspReference: "",
    reference: undefined,
    resultCode: "",
  };
}

export const AllInOneOutput: MessageFns<AllInOneOutput> = {
  encode(message: AllInOneOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== undefined) {
      Action.encode(message.action, writer.uint32(10).fork()).join();
    }
    if (message.amount !== undefined) {
      Amount.encode(message.amount, writer.uint32(18).fork()).join();
    }
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(26).fork()).join();
    }
    if (message.customer !== undefined) {
      Customer.encode(message.customer, writer.uint32(34).fork()).join();
    }
    if (message.refusalReason !== "") {
      writer.uint32(42).string(message.refusalReason);
    }
    if (message.pspReference !== "") {
      writer.uint32(50).string(message.pspReference);
    }
    if (message.reference !== undefined) {
      writer.uint32(58).string(message.reference);
    }
    if (message.resultCode !== "") {
      writer.uint32(66).string(message.resultCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllInOneOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllInOneOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = Action.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = Amount.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customer = Customer.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refusalReason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pspReference = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resultCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllInOneOutput {
    return {
      action: isSet(object.action) ? Action.fromJSON(object.action) : undefined,
      amount: isSet(object.amount) ? Amount.fromJSON(object.amount) : undefined,
      order: isSet(object.order) ? Order.fromJSON(object.order) : undefined,
      customer: isSet(object.customer) ? Customer.fromJSON(object.customer) : undefined,
      refusalReason: isSet(object.refusalReason) ? globalThis.String(object.refusalReason) : "",
      pspReference: isSet(object.pspReference) ? globalThis.String(object.pspReference) : "",
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      resultCode: isSet(object.resultCode) ? globalThis.String(object.resultCode) : "",
    };
  },

  toJSON(message: AllInOneOutput): unknown {
    const obj: any = {};
    if (message.action !== undefined) {
      obj.action = Action.toJSON(message.action);
    }
    if (message.amount !== undefined) {
      obj.amount = Amount.toJSON(message.amount);
    }
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    if (message.customer !== undefined) {
      obj.customer = Customer.toJSON(message.customer);
    }
    if (message.refusalReason !== "") {
      obj.refusalReason = message.refusalReason;
    }
    if (message.pspReference !== "") {
      obj.pspReference = message.pspReference;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.resultCode !== "") {
      obj.resultCode = message.resultCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllInOneOutput>, I>>(base?: I): AllInOneOutput {
    return AllInOneOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllInOneOutput>, I>>(object: I): AllInOneOutput {
    const message = createBaseAllInOneOutput();
    message.action = (object.action !== undefined && object.action !== null)
      ? Action.fromPartial(object.action)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Amount.fromPartial(object.amount)
      : undefined;
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    message.customer = (object.customer !== undefined && object.customer !== null)
      ? Customer.fromPartial(object.customer)
      : undefined;
    message.refusalReason = object.refusalReason ?? "";
    message.pspReference = object.pspReference ?? "";
    message.reference = object.reference ?? undefined;
    message.resultCode = object.resultCode ?? "";
    return message;
  },
};

function createBaseAllInOneRes(): AllInOneRes {
  return { data: undefined, code: "", msg: "", serverTime: "0", success: false };
}

export const AllInOneRes: MessageFns<AllInOneRes> = {
  encode(message: AllInOneRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      AllInOneOutput.encode(message.data, writer.uint32(10).fork()).join();
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.msg !== "") {
      writer.uint32(26).string(message.msg);
    }
    if (message.serverTime !== "0") {
      writer.uint32(32).uint64(message.serverTime);
    }
    if (message.success !== false) {
      writer.uint32(40).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllInOneRes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllInOneRes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = AllInOneOutput.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.msg = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.serverTime = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllInOneRes {
    return {
      data: isSet(object.data) ? AllInOneOutput.fromJSON(object.data) : undefined,
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
      serverTime: isSet(object.serverTime) ? globalThis.String(object.serverTime) : "0",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: AllInOneRes): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = AllInOneOutput.toJSON(message.data);
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    if (message.serverTime !== "0") {
      obj.serverTime = message.serverTime;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllInOneRes>, I>>(base?: I): AllInOneRes {
    return AllInOneRes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllInOneRes>, I>>(object: I): AllInOneRes {
    const message = createBaseAllInOneRes();
    message.data = (object.data !== undefined && object.data !== null)
      ? AllInOneOutput.fromPartial(object.data)
      : undefined;
    message.code = object.code ?? "";
    message.msg = object.msg ?? "";
    message.serverTime = object.serverTime ?? "0";
    message.success = object.success ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
